'use client';

import React, { createContext, useContext, ReactNode, useState, useEffect } from 'react';
import { {{pascalCase name}}Data } from '../types/{{name}}-types';

interface {{pascalCase name}}ContextValue {
  current{{pascalCase name}}: {{pascalCase name}}Data | null;
  {{name}}s: {{pascalCase name}}Data[];
  loading: boolean;
  error: string | null;
  setCurrent{{pascalCase name}}: ({{name}}: {{pascalCase name}}Data | null) => void;
  refresh{{pascalCase name}}s: () => Promise<void>;
  create{{pascalCase name}}: (values: Omit<{{pascalCase name}}Data, 'id' | 'createdAt' | 'updatedAt'>) => Promise<void>;
  update{{pascalCase name}}: (id: string, values: Partial<{{pascalCase name}}Data>) => Promise<void>;
  delete{{pascalCase name}}: (id: string) => Promise<void>;
}

const {{pascalCase name}}Context = createContext<{{pascalCase name}}ContextValue | undefined>(undefined);

interface {{pascalCase name}}ProviderProps {
  children: ReactNode;
  initial{{pascalCase name}}s?: {{pascalCase name}}Data[];
}

export const {{pascalCase name}}Provider: React.FC<{{pascalCase name}}ProviderProps> = ({ 
  children, 
  initial{{pascalCase name}}s = [] 
}) => {
  const [current{{pascalCase name}}, setCurrent{{pascalCase name}}] = useState<{{pascalCase name}}Data | null>(null);
  const [{{name}}s, set{{pascalCase name}}s] = useState<{{pascalCase name}}Data[]>(initial{{pascalCase name}}s);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  const refresh{{pascalCase name}}s = async () => {
    try {
      setLoading(true);
      setError(null);
      // Implementar busca de {{name}}s da API
      // const response = await fetch('/api/{{name}}s');
      // const data = await response.json();
      // if (data.ok) {
      //   set{{pascalCase name}}s(data.data);
      // }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao carregar {{name}}s');
    } finally {
      setLoading(false);
    }
  };

  const create{{pascalCase name}} = async (values: Omit<{{pascalCase name}}Data, 'id' | 'createdAt' | 'updatedAt'>) => {
    try {
      setLoading(true);
      setError(null);
      // Implementar criação via API
      // const response = await fetch('/api/{{name}}s', {
      //   method: 'POST',
      //   body: JSON.stringify(values),
      // });
      // const data = await response.json();
      // if (data.ok) {
      //   await refresh{{pascalCase name}}s();
      // }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao criar {{name}}');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const update{{pascalCase name}} = async (id: string, values: Partial<{{pascalCase name}}Data>) => {
    try {
      setLoading(true);
      setError(null);
      // Implementar atualização via API
      // const response = await fetch(`/api/{{name}}s?id=${id}`, {
      //   method: 'PUT',
      //   body: JSON.stringify(values),
      // });
      // const data = await response.json();
      // if (data.ok) {
      //   await refresh{{pascalCase name}}s();
      // }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao atualizar {{name}}');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const delete{{pascalCase name}} = async (id: string) => {
    try {
      setLoading(true);
      setError(null);
      // Implementar exclusão via API
      // const response = await fetch(`/api/{{name}}s?id=${id}`, {
      //   method: 'DELETE',
      // });
      // const data = await response.json();
      // if (data.ok) {
      //   await refresh{{pascalCase name}}s();
      // }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao deletar {{name}}');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    refresh{{pascalCase name}}s();
  }, []);

  const value: {{pascalCase name}}ContextValue = {
    current{{pascalCase name}},
    {{name}}s,
    loading,
    error,
    setCurrent{{pascalCase name}},
    refresh{{pascalCase name}}s,
    create{{pascalCase name}},
    update{{pascalCase name}},
    delete{{pascalCase name}},
  };

  return (
    <{{pascalCase name}}Context.Provider value={value}>
      {children}
    </{{pascalCase name}}Context.Provider>
  );
};

export const use{{pascalCase name}} = (): {{pascalCase name}}ContextValue => {
  const context = useContext({{pascalCase name}}Context);
  if (!context) {
    throw new Error('use{{pascalCase name}} must be used within a {{pascalCase name}}Provider');
  }
  return context;
};