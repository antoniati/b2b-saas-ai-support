// Este é o arquivo de esquema Prisma,
// Saiba mais sobre ele na documentação: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 
model Tenant {
  id        String       @id @default(cuid())
  name      String
  domain    String?      @unique
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  slug      String
  active    Boolean      @default(true)
  users     User[]
  tickets   Ticket[]
  faqs      FaqArticle[]
  plan      Plan         @relation(fields: [planId], references: [id])
  planId    String
}

model User {
  id                 String           @id @default(cuid())
  name               String
  email              String           @unique
  password           String
  role               Role             @default(USER)
  status         UserStatus       @default(PENDING)
  tenantId           String
  tenant             Tenant           @relation(fields: [tenantId], references: [id])
  tickets            Ticket[]         @relation("TicketAssignee")
  isTwoFactorEnabled Boolean          @default(false)
  isEmailVerified    DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt
  Ticket             Ticket[]
  TicketResponse     TicketResponse[]
}

enum Role {
  OWNER
  ADMIN
  AGENT
  USER
}

enum UserStatus {
  PENDING // Convite pendente
  ACTIVE // Usuário ativo
  INACTIVE // Usuário inativo
}

model Token {
  id      String    @id @default(cuid())
  email   String
  token   String    @unique
  type    TokenType @default(EMAIL_VERIFICATION)
  expires DateTime

  @@unique([email, token])
}

enum TokenType {
  LOGIN
  EMAIL_VERIFICATION
  RESET_PASSWORD
  RECOVER_PASSWORD
  TWO_FACTOR
  INVITATION
}

model Plan {
  id       String   @id @default(cuid())
  name     PlanName @default(mensal)
  features String[]

  Tenant Tenant[]
}

enum PlanName {
  mensal
  anual
}

/// Tickets de suporte
model Ticket {
  id         String           @id @default(cuid())
  subject    String
  content    String
  status     TicketStatus     @default(OPEN)
  tenantId   String
  tenant     Tenant           @relation(fields: [tenantId], references: [id])
  creatorId  String
  creator    User             @relation(fields: [creatorId], references: [id])
  assigneeId String?
  assignee   User?            @relation("TicketAssignee", fields: [assigneeId], references: [id])
  responses  TicketResponse[]
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
}

/// Status do ticket
enum TicketStatus {
  OPEN
  PENDING
  RESOLVED
  CLOSED
}

/// Respostas do ticket (incluindo IA)
model TicketResponse {
  id        String   @id @default(cuid())
  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id])
  senderId  String?
  sender    User?    @relation(fields: [senderId], references: [id])
  message   String
  isAi      Boolean  @default(false)
  createdAt DateTime @default(now())
}

/// FAQ / Base de conhecimento
model FaqArticle {
  id           String         @id @default(cuid())
  tenantId     String
  tenant       Tenant         @relation(fields: [tenantId], references: [id])
  question     String
  answer       String
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  FaqEmbedding FaqEmbedding[]
}

/// Embeddings opcionais para RAG (IA contextual)
model FaqEmbedding {
  id        String     @id @default(cuid())
  faqId     String
  faq       FaqArticle @relation(fields: [faqId], references: [id])
  vector    Float[] // vetor gerado pelo modelo de IA
  createdAt DateTime   @default(now())
}
